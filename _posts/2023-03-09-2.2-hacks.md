---
toc: true
comments: false
layout: post
title: 2.2 and 2.3 hacks
description: hacks for 2.2 and 2.3
permalink: /2hacks
categories: [collegeboard, blog, mcq] 
---

# 2.2 hacks

## AP Prep


###  In the Blog add notes and observations on each code cell that request an answer.

#### code block 2

1. image_data(): prepares a series of images and returns a list of image dictionaries.
2. scale_image(): scales a PIL image to a base width of 320 and returns the resized image.
3. image_to_base64(): converts a PIL image to a base64 representation.
4. image_management(): sets properties of an image, scales it, and converts it to base64.
5. image_management_add_html_grey(): creates a grayscale representation of an image and adds it as HTML.
6. if __name__ == "__main__":: checks whether the script is being run directly or being imported.
7. Displays meta data, scaled view, and grayscale for each image in the images list.

#### code block 3

1. The code defines a Image_Data class that encapsulates image data and methods to manipulate images.
2. The Image_Data constructor initializes the object with source, label, file, path, and baseWidth attributes.
3. The scale_image() method scales an image to the desired width.
4. The image_to_html() method converts a PIL image to base64 HTML code.
5. The image_to_html_grey() method converts a PIL image to grayscale.
6. The image_data() function prepares a series of images and returns the path and images.
7. The image_objects() function creates objects of Image_Data for each image and returns a list of them.
8. The if __name__ == "__main__": section prints the metadata, scaled image, and grayscale image of each image object.

---

### In blog add College Board practice problems for 2.3

---

### Choose 2 images, one that will more likely result in lossy data compression and one that is more likely to result in lossless data compression. Explain.

the image that might loss color as a result of lossy compression is this image: 
![lmao](https://w7.pngwing.com/pngs/430/586/png-transparent-thumbs-up-smiley-face-emoji-happy-smiley-face-thumb-positive.png)
this is becuase it has a lot of color and it will look more pixalated when it is compressed.

the image that might not loose much of its meta-data might be this image: 
![image](https://res.cloudinary.com/dzdgpwtox/image/upload/w_600,c_scale/v1657201570/designer-tool-uploads/bucket_7724/1657201348960.png)
this is because the picture does not have varying shades of color and therefore will bnot look as pixelated as the first picture. 

--- 

## Project Addition

nope, out project does not have any images in it. 

---

## Pick a programming paradigm and solve some of the following ...


### Numpy, manipulating pixels.
```
import numpy as np
from PIL import Image

# load the image and convert to a Numpy array
img = Image.open("image.png")
img_arr = np.array(img)

# define a function to manipulate the image by a certain color channel
def manipulate_color_channel(img_arr, color_channel, intensity):
    # copy the original array to avoid modifying it directly
    manipulated_arr = img_arr.copy()
    # index the color channel and multiply by the desired intensity
    manipulated_arr[:, :, color_channel] *= intensity
    # make sure the pixel values are within the valid range of 0-255
    manipulated_arr = np.clip(manipulated_arr, 0, 255)
    # convert the array back to an image
    manipulated_img = Image.fromarray(manipulated_arr.astype(np.uint8))
    return manipulated_img

# manipulate the image using the red color channel
manipulated_img = manipulate_color_channel(img_arr, 0, 2)
manipulated_img.show()

# manipulate the image using the green color channel
manipulated_img = manipulate_color_channel(img_arr, 1, 1.5)
manipulated_img.show()

# manipulate the image using the blue color channel
manipulated_img = manipulate_color_channel(img_arr, 2, 0.5)
manipulated_img.show()
```

### Binary and Hexadecimal reports.

```
import cv2
import numpy as np

# Read the image in grayscale
img = cv2.imread('example.jpg', cv2.IMREAD_GRAYSCALE)

# Convert to red scale
red_img = np.zeros_like(img)
red_img[:, :, 0] = img

# Display pixel values in binary and hexadecimal formats
for i in range(10):
    for j in range(10):
        pixel_value = red_img[i, j]
        binary_value = '{0:b}'.format(pixel_value)
        hex_value = '{0:x}'.format(pixel_value)
        print(f"Pixel value: {pixel_value}, Binary value: {binary_value}, Hex value: {hex_value}")
```

### Compression and Sizing of images.

```
from PIL import Image

# Open the original image
img = Image.open('original_image.jpg')

# Save the image in PNG format with maximum compression
img.save('compressed_image.png', optimize=True, compress_level=9)
```

### Blur the image or write Meta Data on screen, aka Title, Author and Image size.

```
from PIL import Image, ImageDraw, ImageFont, ImageFilter

class ImageEditor:
    def __init__(self, file_path):
        self.image = Image.open(file_path)
        self.width, self.height = self.image.size

    def blur(self, radius=10):
        self.image = self.image.filter(ImageFilter.GaussianBlur(radius))

    def add_meta_data(self, title, author):
        font = ImageFont.truetype('arial.ttf', size=20)
        draw = ImageDraw.Draw(self.image)
        draw.text((10, 10), f'Title: {title}', font=font, fill='white')
        draw.text((10, 40), f'Author: {author}', font=font, fill='white')
        draw.text((10, self.height - 30), f'Image size: {self.width} x {self.height}', font=font, fill='white')

    def save_image(self, file_path):
        self.image.save(file_path)

# Example usage
editor = ImageEditor('example_image.jpg')
editor.blur(radius=15)
editor.add_meta_data('Beautiful Scenery', 'John Doe')
editor.save_image('edited_image.jpg')
```
---

# 2.3 hacks
 